<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Geometrical Capture Demo – fixed</title>
  <link rel="stylesheet" href="styles.css"/>
  <!-- webm encoder polyfill -->
  <script src="https://cdn.jsdelivr.net/npm/webm-writer@0.3.0/dist/webm-writer.min.js"></script>
</head>
<body>
  <div id="wrapper">
    <canvas id="canvas" width="640" height="640"></canvas>

    <div id="controls">
      <label>Size  <input type="range" id="sizeRange"  min="40"  max="200" value="120"></label>
      <label>Speed <input type="range" id="speedRange" min="0.1" max="3"   step="0.1" value="1"></label>
      <label>Hue   <input type="range" id="hueRange"   min="0"   max="360" value="0"></label>
      <label>Glow  <input type="range" id="glowRange"  min="0"   max="50"  value="20"></label>

      <button id="downloadBtn">Download 7-s WEBM</button>
    </div>
  </div>

<script>
/* ---------- configurable parameters ---------- */
const cfg = {
  size: 120,
  speed: 1,
  hueOffset: 0,
  glow: 20
};

/* ---------- WebGL boilerplate ---------- */
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');
if (!gl) { alert('WebGL unavailable'); }

/* util */
function compile(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    throw gl.getShaderInfoLog(s);
  return s;
}

/* shaders */
const vs = `
attribute vec3 aPos;
uniform mat4 uMVP;
void main() {
  gl_Position = uMVP * vec4(aPos, 1.0);
}
`;
const fs = `
precision mediump float;
uniform float uHue;
uniform float uTime;
void main() {
  vec3 rgb = 0.5 + 0.5*cos(uHue/360.0*6.28318 + vec3(0,2,4) + uTime);
  gl_FragColor = vec4(rgb, 1.0);
}
`;

/* program */
const prog = gl.createProgram();
gl.attachShader(prog, compile(gl.VERTEX_SHADER,   vs));
gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fs));
gl.linkProgram(prog);
gl.useProgram(prog);

/* cube vertices (wireframe, 8 points) */
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1,-1,  1,-1,-1,  1, 1,-1, -1, 1,-1,
  -1,-1, 1,  1,-1, 1,  1, 1, 1, -1, 1, 1
]), gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog, 'aPos');
gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
gl.enableVertexAttribArray(aPos);

/* 12 edges → 24 indices */
const ibo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array([
  0,1,1,2,2,3,3,0,
  4,5,5,6,6,7,7,4,
  0,4,1,5,2,6,3,7
]), gl.STATIC_DRAW);

/* uniforms */
const uMVP  = gl.getUniformLocation(prog, 'uMVP');
const uHue  = gl.getUniformLocation(prog, 'uHue');
const uTime = gl.getUniformLocation(prog, 'uTime');

gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
gl.lineWidth(3);

/* ---------- draw loop ---------- */
let time = 0;
(function loop(ms) {
  time = ms * 0.001;

  /* update uniforms */
  gl.uniform1f(uHue,  cfg.hueOffset);
  gl.uniform1f(uTime, time * cfg.speed);

  /* simple rotation matrix */
  const c = Math.cos(time * cfg.speed);
  const s = Math.sin(time * cfg.speed);
  const scale = cfg.size / 100;
  const mvp = new Float32Array([
    c*scale,  s*scale, 0, 0,
   -s*scale,  c*scale, 0, 0,
    0, 0, scale, 0,
    0, 0, 0, 1
  ]);
  gl.uniformMatrix4fv(uMVP, false, mvp);

  /* draw */
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.drawElements(gl.LINES, 24, gl.UNSIGNED_BYTE, 0);

  requestAnimationFrame(loop);
})(0);

/* ---------- UI ---------- */
['sizeRange','speedRange','hueRange','glowRange'].forEach(id =>
  document.getElementById(id).addEventListener('input', e =>
    cfg[id.replace('Range','')] = +e.target.value));

/* ---------- download ---------- */
const btn = document.getElementById('downloadBtn');
let recording = false;

btn.addEventListener('click', async () => {
  if (recording) return;
  recording = true;
  btn.disabled = true;
  btn.textContent = 'Recording…';

  /* wait one frame so the canvas has real content */
  await new Promise(r => requestAnimationFrame(r));

  const stream = canvas.captureStream(60);
  const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'geometry_7s.webm';
    a.click();
    URL.revokeObjectURL(url);
    recording = false;
    btn.disabled = false;
    btn.textContent = 'Download 7-s WEBM';
  };
  recorder.start();
  setTimeout(() => recorder.stop(), 7000);
});
</script>
</body>
</html>
